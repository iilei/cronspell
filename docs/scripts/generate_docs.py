# mypy: ignore-errors


import calendar
import re
import subprocess  # noqa: S404
import sys
from codecs import decode, encode
from functools import cmp_to_key
from textwrap import dedent

import pydot
from bs4 import BeautifulSoup
from bs4.builder._htmlparser import HTMLParserTreeBuilder  # noqa: PLC2701
from datauri import DataURI
from pygments import highlight
from pygments.formatters import HtmlFormatter
from pygments.lexers import find_lexer_class_by_name


class MyTreeBuilder(HTMLParserTreeBuilder):
    DEFAULT_PRESERVE_WHITESPACE_TAGS = {"pre", "textarea", "code"}  # noqa: RUF012


path = "src/cronspell/cronspell"
graph = pydot.graph_from_dot_file(f"{path}.dot")[0]
node = graph.get_node("match_rules")[0]

table = re.sub(re.compile(r"(^< )|( >$)"), "", node.get_label())

tag = BeautifulSoup(table, "html.parser")


with open(f"{path}.tx", encoding="utf-8") as file:
    src_lines = [*file.readlines()]


with open(f"{path}.pu", encoding="utf-8") as file:
    plantuml = re.sub(re.compile(r"\nlegend[\S\s\n]+\nend legend\s*\n", re.MULTILINE), "\n\n", file.read())

with open(f"{path}.pu", encoding="utf-8", mode="+w") as file:
    file.write(plantuml)
    file.close()


def get_compare_func(item):
    return re.compile(rf"^\s*{item.findChild('b').get_text()}\s*:").match


def compare(item1, item2):
    a = next((idx for idx, x in enumerate(src_lines) if get_compare_func(item1)(x)), 1)
    b = next((idx for idx, x in enumerate(src_lines) if get_compare_func(item2)(x)), 1)
    return a - b


rows_sorted = sorted(tag.findChildren("tr"), key=cmp_to_key(compare))


def get_example(regex, short, titlecase, lowercase):
    test = re.compile(regex)

    suggested = ""

    with calendar.different_locale(locale=("EN_US", "UTF-8")):
        candidates = [
            *calendar.day_name,
            *calendar.month_name,
            "Year",
            "Day",
            "Month",
            "Hour",
            "Minute",
            "Second",
            "Week",
            "{",
            "}",
            "now",
            "1979-01-01T00:00:00+00:00",
            "/* inline comment */",
        ]

    if short:
        cdts = [
            "// eol commentm",
            "% Y",
            "% M",
            r"% cw",
            "years",
            "days",
            "months",
            "hours",
            "minutes",
            "seconds",
            "weeks",
            *calendar.day_abbr,
            *calendar.month_abbr,
        ]

    if short and not titlecase:
        cdts = [
            "@Y",
            "@M",
            "@cw",
            *[x.lower()[:1] for x in cdts],
            *[x.upper()[:1] for x in cdts],
        ]

    elif titlecase:
        cdts = [
            dedent("""
            /*
                multi-line
                block
                comment
            */
            """).strip(),
            "Years",
            "Days",
            "Months",
            "Hours",
            "Minutes",
            "Seconds",
            "Weeks",
            *[x.title() for x in calendar.day_abbr],
            *[x.title() for x in calendar.month_abbr],
        ]

    else:
        cdts = [*candidates]

    if lowercase:
        cdts = [x if x.startswith("@") else x.lower() for x in candidates]

    suggested = next(
        (x for x in ["1979-01-01T00:00:00+00:00", *cdts] if test.fullmatch(x)),
        "",
    )

    if (short or titlecase) and suggested in {"}", "{", "1979-01-01T00:00:00+00:00"}:
        suggested = ""

    if short and not titlecase and test.fullmatch(_suggested := suggested.lower()):
        suggested = _suggested

    if short and suggested == "now":
        suggested = "now[Europe/Berlin]"

    return suggested


with open("README.md", encoding="utf-8") as file:
    # <!-- start autogenerated: legend -->
    # <!-- end autogenerated: legend -->

    # <!-- start autogenerated: diag -->
    # <!-- end autogenerated: diag -->

    def get_cells(node):
        pattern = decode(encode(node.findChildren("td")[1].get_text(), "utf-8", "backslashreplace"), "utf-8")
        return [
            node.findChild("b").get_text(),
            pattern,
            get_example(pattern, True, False, False),
            get_example(pattern, True, True, False),
            get_example(pattern, False, False, False),
            get_example(pattern, True, True, True),
        ]

    rows = [get_cells(x) for x in rows_sorted]

    section_stop_at = {"Now", "MonthModulo", "S", "Sun", "Dec"}

    def get_row_nodes(x):
        mark_as_yaml = next(iter(x), "") == "ISODate"

        examples = BeautifulSoup().new_tag("td")
        rows = [BeautifulSoup().new_tag("tr")]
        rows[0].append(BeautifulSoup().new_tag("td"))

        for idx, y in enumerate(x):
            node = BeautifulSoup().new_tag("td")
            val = y.strip()

            if idx == 0:
                em = BeautifulSoup().new_tag("em")
                em.string = val
                rows[0].td.append(em)

            elif idx == 1:
                tag = BeautifulSoup().new_tag("td")
                lexer = find_lexer_class_by_name("yaml")()
                tag.append(
                    BeautifulSoup(
                        highlight(val, lexer, HtmlFormatter()), features="html.parser", builder=MyTreeBuilder()
                    )
                )
                rows[0].append(tag)
            if idx >= 2:  # noqa: PLR2004, SIM102
                if val:
                    language = (
                        "yaml"
                        if mark_as_yaml
                        else "cpp"
                        if val.startswith("/*") or val.startswith("//")
                        else "graphviz"
                    )

                    lexer = find_lexer_class_by_name(language)()
                    row = BeautifulSoup().new_tag("div")
                    row.append(
                        BeautifulSoup(
                            highlight(val, lexer, HtmlFormatter()),
                            features="html.parser",
                            builder=MyTreeBuilder(),
                        )
                    )
                    examples.append(row)

        rows[0].append(examples)

        if next(iter(x), "") in section_stop_at:
            row = BeautifulSoup().new_tag("tr")
            node = BeautifulSoup().new_tag("td")
            node["colspan"] = 3
            row.append(node)
            rows.append(row)

        return rows

    rows = [item for it in [get_row_nodes(x) for x in rows] for item in it]

    legend = BeautifulSoup("<table></table>", features="html.parser", builder=MyTreeBuilder()).table

    cpt = BeautifulSoup().new_tag("caption")
    cpt.string = "Legend"
    legend.append(cpt)

    header_row = BeautifulSoup().new_tag("tr")
    for x in ["Entity", "Pattern", "Examples"]:
        node = BeautifulSoup().new_tag("th")
        node.string = x
        node["scope"] = "col"
        header_row.append(node)

    for row in [header_row, *rows]:
        legend.append(row)

    legend_html = legend.prettify()

    part_a, part_b = re.split(
        r"\n<!-- start autogenerated: legend -->[\S\s\n]+<!-- end autogenerated: legend -->\n",
        file.read(),
        flags=re.IGNORECASE | re.MULTILINE,
        maxsplit=0,
    )

    doc = "\n".join(
        [part_a, "<!-- start autogenerated: legend -->", legend_html, "<!-- end autogenerated: legend -->", part_b]
    )


with open("README.md", encoding="utf-8", mode="+w") as file:
    file.write(doc)
    file.close()


sys.exit(0)

with open("README.md", encoding="utf-8") as file:
    # <!-- start autogenerated: cronspell -->
    # <!-- end autogenerated: cronspell -->

    mksvg = subprocess.run(  # noqa: S603
        ["plantuml", f"{path}.pu", "-tsvg", "-Slinetype=polyline", "-Smonochrome=true", "-Sshadowing=false"],  # noqa: S607
        check=False,
    )

    with open(f"{path}.svg", encoding="utf-8") as svgsrc:
        raw = svgsrc.read()

    with open(f"{path}.svg", encoding="utf-8", mode="+w") as svgsrc:
        svgsrc.write(raw.replace("#FFFFFF", "#FFFFFF99").replace("#383838", "#0e3f3ae3").replace("#000000", "#0e3f3a"))

    svguri = str(DataURI.from_file(f"{path}.svg"))

    part_a, part_b = re.split(
        r"\n<!-- start autogenerated: cronspell -->[\S\s\n]+<!-- end autogenerated: cronspell -->\n",
        file.read(),
        flags=re.IGNORECASE | re.MULTILINE,
        maxsplit=0,
    )

    doc = "\n".join(
        [
            part_a,
            "<!-- start autogenerated: cronspell -->",
            "\n",
            f'<img src="{svguri}" />',
            "\n",
            "<!-- end autogenerated: cronspell -->",
            part_b,
        ]
    )

with open("README.md", encoding="utf-8", mode="+w") as file:
    file.write(doc)
    file.close()
