# mypy: ignore-errors


import calendar
import re
from codecs import decode, encode
from functools import cmp_to_key

import pydot
from bs4 import BeautifulSoup

path = "src/cronspell/cronspell"
graph = pydot.graph_from_dot_file(f"{path}.dot")[0]
node = graph.get_node("match_rules")[0]

table = re.sub(re.compile(r"(^< )|( >$)"), "", node.get_label())

tag = BeautifulSoup(table, "html.parser")


with open(f"{path}.tx", encoding="utf-8") as file:
    src_lines = [*file.readlines()]


with open(f"{path}.pu", encoding="utf-8") as file:
    plantuml = re.sub(re.compile(r"\nlegend[\S\s\n]+\nend legend\s*\n", re.MULTILINE), "\n\n", file.read())

with open(f"{path}.pu", encoding="utf-8", mode="+w") as file:
    file.write(plantuml)
    file.close()


def get_compare_func(item):
    return re.compile(rf"^\s*{item.findChild("b").get_text()}\s*:").match


def compare(item1, item2):
    a = next((idx for idx, x in enumerate(src_lines) if get_compare_func(item1)(x)), 1)
    b = next((idx for idx, x in enumerate(src_lines) if get_compare_func(item2)(x)), 1)
    return a - b


rows_sorted = sorted(tag.findChildren("tr"), key=cmp_to_key(compare))


def get_example(regex, short=False):  # noqa: FBT002
    test = re.compile(regex)

    suggested = ""

    with calendar.different_locale(locale=("EN_US", "UTF-8")):
        candidates = [
            *calendar.day_name,
            *calendar.month_name,
            "Year",
            "Day",
            "Month",
            "Hour",
            "Minute",
            "Second",
            "Week",
            "@cw",
            "@m",
            "@y",
            "{",
            "}",
            "now",
            "1979-01-01T00:00:00+00:00",
            "/* inline comment */",
        ]
    if short:
        suggested = next(
            (
                x.replace("@", "%")
                for x in [
                    "// eol comment",
                    "m",
                    *[x[:0] for x in candidates],
                    *[x[:1] for x in candidates],
                    *[x[:3] for x in candidates],
                    *[x[:4] for x in candidates],
                ]
                if test.match(x.replace("@", "%"))
            ),
            "",
        )

    if not short or (suggested == ""):
        suggested = next((x for x in candidates if test.match(x)), "")

    if short and suggested == "now":
        suggested = "now[UTC]"

    if short and suggested in {"}", "{", "1979-01-01T00:00:00+00:00"}:
        suggested = ""

    if short and test.match(_suggested := suggested.lower()):
        suggested = _suggested

    if short and suggested.startswith("%") and test.match(_suggested := suggested.upper()):
        suggested = _suggested

    return suggested


with open("README.md", encoding="utf-8") as file:
    # <!-- start autogenerated: legend -->
    # <!-- end autogenerated: legend -->

    # <!-- start autogenerated: diag -->
    # <!-- end autogenerated: diag -->

    lines = [
        [
            x.findChild("b").get_text(),
            decode(encode(x.findChildren("td")[1].get_text(), "utf-8", "backslashreplace"), "utf-8").replace(
                "|", r"\|"
            ),
            get_example(decode(encode(x.findChildren("td")[1].get_text(), "utf-8", "backslashreplace"), "utf-8")),
            get_example(decode(encode(x.findChildren("td")[1].get_text(), "utf-8", "backslashreplace"), "utf-8"), True),
        ]
        for x in rows_sorted
    ]

    heading = [" $f$ ", "Expression or Literal", "Example", "Alternative Example"]
    longest_a = sorted([*lines, heading], key=cmp_to_key(lambda x, y: len(x[0]) - len(y[0])))[-1][0]
    longest_b = sorted([*lines, heading], key=cmp_to_key(lambda x, y: len(x[1]) - len(y[1])))[-1][1]
    longest_c = sorted([*lines, heading], key=cmp_to_key(lambda x, y: len(x[2]) - len(y[2])))[-1][2]
    longest_d = sorted([*lines, heading], key=cmp_to_key(lambda x, y: len(x[3]) - len(y[3])))[-1][3]

    pad_a = len(longest_a) + 2
    pad_b = len(longest_b) + 12
    pad_c = len(longest_c) + 9
    pad_d = len(longest_d) + 9

    lines = [
        [
            f"*{x[0]}*",
            r"`` %s ``{:.re}" % x[1],  # noqa: UP031
            r"`%s`{:.yml}" % x[2],  # noqa: UP031
            r"`%s`{:.yml}" % x[3] if x[3] else "",  # noqa: UP031
        ]
        for x in lines
    ]

    lines = [
        heading,
        ["-" * pad_a, "-" * pad_b, "-" * pad_c, "-" * pad_d],
        *lines,
    ]

    def insert_verti_padd(where):
        break_here = next((idx for idx, x in enumerate(lines) if any(f"*{where}*" in y for y in x)), -2) + 1

        return [
            *lines[:break_here],
            [" " * pad_a, " " * pad_b, " " * pad_c, " " * pad_d],
            *lines[break_here:],
        ]

    lines = insert_verti_padd("MonthModuloMarker")
    lines = insert_verti_padd("S")
    lines = insert_verti_padd("Sun")
    lines = insert_verti_padd("Dec")

    legend = "\n".join([f"| {x[0]:{pad_a}} | {x[1]:{pad_b}} | {x[2]:{pad_c}} | {x[3]:{pad_d}} |" for x in lines])

    part_a, part_b = re.split(
        r"\n<!-- start autogenerated: legend -->[\S\s\n]+<!-- end autogenerated: legend -->\n",
        file.read(),
        flags=re.IGNORECASE | re.MULTILINE,
        maxsplit=0,
    )

    doc = "\n".join(
        [part_a, "<!-- start autogenerated: legend -->", legend, "<!-- end autogenerated: legend -->", part_b]
    )


with open("README.md", encoding="utf-8", mode="+w") as file:
    file.write(doc)
    file.close()
